<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Univerzális programozás</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Írd meg a saját programozás tankönyvedet!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <surname>Schachinger</surname>
            <firstname>Zsolt</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>Hallgató</shortaffil>
            <jobtitle>Hallgató</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>Programtervező informatikus</orgdiv>
            <address>
                <email>salesz19990203@outlook.com</email>
            </address>
        </affiliation>
        <address>
            <street>Kassai út 26.</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
            <email>salesz19990203@outlook.com</email>
            <otheraddr>
                <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/">https://arato.inf.unideb.hu/batfai.norbert/</link>
            </otheraddr>
        </address>
    </author>    
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2019. február 19, v. 0.0.4</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Aktualizálás, javítások.
        </revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>                  
                          
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Olvasgasd a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para><citation>KERNIGHANRITCHIE</citation></para>                        
                </listitem>
                <listitem>
                    <para><citation>BMECPP</citation></para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás forrása:                
        </para>
	<programlisting language="c"><![CDATA[Program procheating
{
	#include <stdio.h>
	#include <omp.h>

	int main()
	{
	#pragma omp parallel for
	for (int i=0; i<10;i++)
	{
		i--;
	}

	}
}]]></programlisting>
        <para>
            Az OpenMP (Open Multi-Processing) egy api, ami támogatja a multi többprocesszoros programozást. Ilyen esetben, ezt sokkal egyszerűbb használni, mintsem elkezdenénk a több-szálkezelő
            (multithread) módszerrel dolgozni..
        </para>
        <para>
	Azt, hogy a program a processzor összes magját kihasználja, OpenMP segítségével oldottam meg. Ez nagyobb programoknál alapszabály, hogy gondoskodjunk a processzor teljes kihasználtságáról.
        </para>     
        <mediaobject>
            
            <imageobject>
                <imagedata fileref="../pictures/procheating.png"/>
            </imageobject>
            
            <caption>
                <para>Ubuntu linux screenshot</para>
            </caption>
            
        </mediaobject>       
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne végtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Ezt a programot matematikailag lehetetlen megírni számunkra. Ugyanis ilyen program, mint a feladat közben is olvashatjuk nem hozható létre.
            Ha elkezdjük boncolgatni a problémát, újabb problémába ütközünk, hiszen hamar ellentmondást kapunk a dolgok vizsgálata kapcsán... Elvégre többször 
            is bizonyítva volt már sok nagyobb ember által is, hogy a program nem megírható.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <programlisting language="c"><![CDATA[Program procheating
{
	#include <stdio.h>

        int main()
        {
        //change the values with an extra variable
        int a, b, c;
        a=2;
        b=5;
        c=0;

        //before the trade
        printf("csere elott:\na=%d, b=%d\n",a,b);
        c=a;
        a=b;
        b=c;
        //after the trade
        printf("csere utan:\na=%d, b=%d\n",a,b);

        //no extra variable used..
        //change values with exor
        a=3;
        b=8;

        //values before the trade
        printf("\ncsere exorral:\n");
        printf("csere elott:\na=%d, b=%d\n",a,b);

        a=a+b;
        b=a-b;
        a=a-b;

        printf("csere utan:\na=%d, b=%d\n",a,b);
        }

}]]></programlisting>
            <para>
            Mint fent látható, először segédváltozóval oldom meg a cserét, aztán segédváltozó használata nélkül, művelettel(összeadás, kivonás).
            </para>
            <para>
                Jelen esetben a műveletekkel való csere előtt, az <function>a</function> értéke 3, a <function>b</function> értéke 8. Hogyan is zajlik pontosan itt a csere?
            </para>
            <para>
            Így:
            </para>
            <programlisting>
            a = 3
            b = 8
            a = a + b -&gt; a = 11 (3+8)
            b = a - b -&gt; b = 3 (11-8)
            a = a - b -&gt; a = 8 (11-3)
            </programlisting>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            használata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/Salesz9902/prog1/blob/master/bouncingball.c">https://github.com/Salesz9902/prog1/blob/master/bouncingball.c
            <filename>/prog1/blob/master/bouncingball.c</filename></link>
        </para>
        <para>
            Ahhoz, hogy a programot megfelelően tudjuk fordítani, használnunk kell a <function>-lncurses</function> kapcsolót a következő módon:
            <programlisting>
            gcc "programneve" -o "futtathatoneve" -lncurses
            </programlisting>
        </para>
        <para>
            Ahhoz, pedig, hogy tudjuk használni a -lncurses kapcsolót, telepítenünk kell a libncurses5-dev-et:
            <programlisting>
                sudo apt-get install libncurses5-dev
            </programlisting>
        </para>
        <para>
            Az if nélküli módszer 
            <programlisting language="c"><![CDATA[Program procheating
            {
                    #include <stdio.h>
            #include <stdlib.h>
            #include <curses.h>
            #include <unistd.h>

            int main(void)
            {
                int xj = 0, xk = 0, yj = 0, yk = 0;
                int mx = 80 * 2, my = 24 * 2;

                WINDOW *ablak;
                ablak = initscr();
                noecho ();
                cbreak ();
                nodelay (ablak,true);

                for (;;)
                {
                    xj = (xj - 1) % mx;
                    xk = (xk + 1) % mx;

                    yj = (yj - 1) % my;
                    yk = (yk + 1) % my;

                    clear();

                    mvprintw(0, 0,
                             "---------------------------------------------------------------");
                             mvprintw(24, 0,
                             "---------------------------------------------------------------");
                             mvprintw(abs ((yj + (my - yk)) / 2),
                                        abs ((xj + (mx - xk)) / 2), "X");
                    refresh();
                    usleep(150000);
                }
                return 0;
            }

            }]]></programlisting>
        </para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Salesz9902/prog1/blob/master/bogomips.c">https://github.com/Salesz9902/prog1/blob/master/bogomips.c</link>
        </para>
        <para>
            A BogoMIPS a processzor egy magjának a gyorsaságát méri meg 1 másodperc alatt. Sokan így akarják összehasonlítani számítógépük erősségét, ezt nem erre találták ki.
        </para>
        <mediaobject>
            
            <imageobject>
                <imagedata fileref="../pictures/bogomips.png"/>
            </imageobject>
            
            <caption>
                <para>Ubuntu linux screenshot</para>
            </caption>
            
        </mediaobject>  
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/Salesz9902/prog1/blob/master/pagerank.c">https://github.com/Salesz9902/prog1/blob/master/pagerank.c</link>
        </para>
        <para>
            A PageRank egy olyan algoritmus, amely linkekhez számokat rendel, majd azokat sorrendbe teszi a hálózatban betöltött szerepük alapján. A Google keresőmotorjának ez az egyik
            legfontosabb eleme. A PageRank szó egyben a a Google bejegyzett védjegye.
        </para>
        <para>
            Ez alapján egyértelműen látjuk, hogy melyik weboldal mennyire fontos, és segítségével hasznos listát tudunk felállítani az oldalak fontosságáról.
        </para>
        
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/salesz9902/prog1/blob/master/brun.r">https://github.com/salesz9902/prog1/blob/master/brun.r</link>
        </para>
        <para>
            A Brun tétel az ikerprímszámok reciprokaiból képez sorösszegeket, Brun konstans néven ismert véges értékhez konvergál. 
        </para>
        <para>
            A példánkban egy olyan programot írtunk, amely próbálja megközelíteni a Brun konstans értékét. Tehát kiszámolja az ikerprímeket, összegzi a reciprokaikat és részeredményt mutat.
        </para>
        <para>
            Tisztázzuk az ikerprím fogalmát:
        </para>
        <para>
            Ikerprímnek két olyan prímszám együttesét nevezzük, amelyek 2-vel térnek el egymástól: például 5 és 7. Mivel a prímszámok (a 2-t kivéve) csak páratlan számok lehetnek, két prímszám 
            között nem lehet kisebb a különbség 2-nél (a (2, 3) pár kivételével). Más megfogalmazás szerint: az ikerprímek két olyan prímszám együttese, amelyek között a prímhézag 2. 
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/salesz9902/prog1/blob/master/montyhall.r">https://github.com/salesz9902/prog1/blob/master/montyhall.r</link>
        </para>
        <para>
            Kép forrása: <link xlink:href="https://probabilityandstats.wordpress.com/2017/05/11/monty-hall-problem/">https://probabilityandstats.wordpress.com/2017/05/11/monty-hall-problem/</link>
        </para>
        <para>
            A Monty Hall egy valószínűségi paradoxon. Az Egyesült Államokban, a Let's Make a Deal televíziós vetélkedő egyik feladatán alapul. Nevét a műsorvezetőről, Monty Hall-ról kapta.
        </para>
        <para>
            A probléma alap kiindulása az, hogy van 3 csukott ajtónk, amelyek közül 2 mögött van valami számunkra értéktelen dolog, viszont az egyik mögött valami rendkívül értékes lapul.
            Azt kapjuk meg, amelyik az általunk választott ajtó mögött van. Tehát létezik egy egyszerű valószínűségszámítási eszköz, amely megmutatja, hogy melyik ajtót érdemes nekünk
            választani az adott esetben.
        </para>
        <para>
            Először tegyük fel, hogy van 1-es 2-es és 3-as ajtónk. A játékosunk először a 3-as ajtót választja. Itt 1/3 eséllyel lesz értékes tárgy. Majd kinyílik a 2-es ajtó. Ez egy 
            értéktelen tárgy lett, ezért ott 0 eséllyel lesz értékes, viszont a mellette lévőben 2/3 az esély.
        </para>
        <mediaobject>
            
            <imageobject>
                <imagedata fileref="../pictures/montyhall.jpg"/>
            </imageobject>
            
            <caption>
                <para>Az egyik ajtó mögött egy autó, másik kettő mögött kecske található. Az autót keressük. Képen egyértelműen láthatjuk mennyi eséllyel találjuk meg az autót az 
                ajtókban, így, hogy már 1 ajtót kinyitottunk, amiben kecske van.</para>
            </caption>
            
        </mediaobject> 
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás forrása:   <link href="https://github.com/salesz9902/prog1/blob/master/binarunary.c">https://github.com/salesz9902/prog1/blob/master/binarunary.c</link>    
        </para>
        <para>
            A Turing-gép Alan Turing angol matematikushoz fűződik, hiszen ő dolgozta ki ennek fogalmát. Ez mindenféle folyamat precízebb megfogalmazására
            lett kitalálva. Például eljárások, algoritmusok pontosabb leírására.
        </para>
        <para>
            Írnom kell az unáris számrendszerről is. Ez egy nagyon egyszerű számrendszer, amiben vonalakkal ábrázoljuk a számokat.
            Vegyük példának az 5-öt, ezt öt vonallal ábrázoljuk, a következőképpen:
        </para> 
            <para>
                <code>||||| = 5</code>
            </para>
        <para>
            A programunk annyit csinál, hogy bekér a felhasználótól egy decimális számot, majd azt kiírja unárisban, 5-ösével elválasztva.
        </para>
        <mediaobject>
            
            <imageobject>
                <imagedata fileref="../pictures/binarunary.png"/>
            </imageobject>
            
            <caption>
                <para>Ubuntu linux screenshot</para>
            </caption>
            
        </mediaobject>  
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Legyenek <emphasis>S, X, Y</emphasis> változók.
            Legyen <emphasis>a, b, c</emphasis> konstansok.
        </para>
        <para>
            <emphasis>S -&gt; abc, S-&gt;aXbc, Xb -&gt; bX, Xc -&gt; Ybcc, bY -&gt; Yb, Ay &gt; aax, Ay -&gt; aa</emphasis>
        </para>
        <para>
            Noam Chomsky szintén egy nyelvész volt, akinek a fenti nyelv grammatikáját is köszönhetjük. Érdekes módon rengeteg kiemelkedő foglalkozása mellett informatikus is volt.
        </para>
        <programlisting>
                <![CDATA[S, X, Y: „változók” (a nemterminálisok)
        a, b, c: „konstansok” (a terminálisok)
        S → abc, S → aXbc, Xb → bX, Xc → Ybcc, bY → Yb, aY -> aaX, aY → aa (a helyettesítési szabályok)
        S (a mondatszimbólum)

            S (S → aXbc)
            aXbc (Xb → bX)
            abXc (Xc → Ybcc)
            abYbcc (bY → Yb)
            aabbcc

            S (S → aXbc)
            aXbc (Xb → bX)
            abXc (Xc → Ybcc)
            abYbcc (bY → Yb)
            aYbbcc (aY -> aaX)
            aaXbbcc (Xb → bX)
            aabXbcc (Xb → bX)
            aabbXcc (Xc → Ybcc)
            aabbYbccc (bY → Yb)
            aabYbbccc (bY → Yb)
            aaYbbbccc (aY → aa)
            aaabbbccc]]> 
        </programlisting>
        <programlisting>
            <![CDATA[A, B, C: „változók” (a nemterminálisok)
            a, b, c: „konstansok” (a terminálisok)
            A → aAB, A → aC, CB → bCc, cB → Bc, C → bc (a képzési szabályok) 
            S (A kezdőszimbólum)

                A (A → aAB)
                aAB ( A → aC)
                aaCB (CB → bCc)
                aabCc (C → bc)
                aabbcc

                A (A → aAB)
                aAB ( A → aAB)
                aaABB ( A → aAB)
                aaaABBB ( A → aC)
                aaaaCBBB (CB → bCc)
                aaaabCcBB (cB → Bc)
                aaaabCBcB (cB → Bc)
                aaaabCBBc (CB → bCc)
                aaaabbCcBc (cB → Bc)
                aaaabbCBcc (CB → bCc)
                aaaabbbCccc (C → bc)
                aaaabbbbcccc]]> 
        </programlisting>

    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás forrása:
            <programlisting language="c"><![CDATA[Program hivatkozasinyelv
               {
                #include <complex.h>
                #include <stdbool.h>

                int main()
                {
                    long long int asd;
                    complex stnum;
                }
           }]]></programlisting>  
        </para>
        <para>
            A C nyelvnek is vannak régebbi, illetve újabb változatai. Ilyen például a C89, illetve a C99. Összehasonlítva a C89-hez képest rengeteg változás történt a C99-ben.
        </para>
        <para>
            Például új header fájlok jöttek be a C99-nél, ilyen a <function>complex.h</function>, <function>stdbool.h</function> vagy a <function>tgmath.h</function>
        </para>
        <para>
            Jelentős újítás volt még például az új típusok: long long int, vagy a complex típus.
        </para>
        <para>
            A fenti kód például C89-ben nem futna le, mivel még nem ismerné a header fájlokat, illetve a long long int típust...
        </para>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás forrása:  
            <programlisting language="c"><![CDATA[Program lexikalis
                %{
                #include <stdio.h>
                int realnumbers = 0;
                %}
                digit	[0-9]
                %%
                {digit}*(\.{digit}+)?	{++realnumbers; 
                    printf("[realnum=%s %f]", yytext, atof(yytext));}
                %%
                int
                main ()
                {
                 yylex ();
                 printf("The number of real numbers is %d\n", realnumbers);
                 return 0;
                }
           }]]></programlisting>
        </para>
        <para>
            A programnak megadjuk/definiáljuk a számokat, ezt a <code>[0-9]</code> sorban láthatjuk.
            Itt azt adjuk meg, hogy bármely szám nullától kilencig, hányszor fordulhat elő.
            Az ez utáni sorban a <code>.|\n {}</code> után következő utasításnál többit figyelmen kívül hagyjuk.
        </para>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás forrása: <link href="https://github.com/Salesz9902/prog1/blob/master/l33t.c">https://github.com/Salesz9902/prog1/blob/master/l33t.c</link> 
        </para>
        <para>
            A leet nyelv egy internetes nyelv. Bizonyos betű karaktereket számokkal helyettesítünk, amik erősen hasonlítanak a betűkhöz.
        </para>
        <para>
            <programlisting>
            Például:
            3 = E
            4 = A
            1 = l
            7 = T
            </programlisting>
            A fentiek ismeretében rájöhetünk, hogy a leet szó =&gt; 1337 leet nyelven írva. De akár írhatjuk így is: l33t 
        </para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>            
            </listitem>
        </orderedlist>

        <para>
            Ebben a programban egy jelkezelővel "játszadozhatunk". Ha a program futása során megnyomjuk a Ctrl+C billentyűkombinációt,
            aminek meg kellene szakítani a folyamatot, először nem fogja. Aztán majd mégegyszeri lenyomás után már másképp veszi figyelembe
            az általunk kiküldött jelet a programunk.
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
            A LaTeX egy texen alapuló szövegformázó rendszer, amely dokumentumok, szakdolgozatok, akár
            tudományos cikkek írására is használnak. Matematikusok gyakran használják.
        </para>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>            
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>            
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>            
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás forrása:  <link href="https://github.com/Salesz9902/prog1/blob/master/deklaracio.c">https://github.com/Salesz9902/prog1/blob/master/deklaracio.c</link>
        </para>
        <para>
            Már a legkisebb programokban is találhatunk változó vagy függvénydeklarációt. Ezek kulcsfontosságúak számunkra, hiszen így tudunk tárolni adatokat egyszerűen amiket
            programunk során felhasználunk. Illetve a függvényekkel saját függvényeket is írhatunk.
        </para>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Megoldás forrása:      <link xlink:href="https://github.com/salesz9902/prog1/blob/master/double_trimatrix.c">https://github.com/salesz9902/prog1/blob/master/double_trimatrix.c</link>
        </para>
        <para>
            Elsősorban megadjuk a mátrix sorainak számát. <function>int nr = 5</function>
            Ezután deklarálunk egy valós értékre mutató mutatót.
        </para>
        <para>
            Érdemes megfigyelnünk a <function>malloc</function> függvényt. 
            5-ször 8 bájtot foglal le, és egy mutatót ad vissza. Ha 0 a méret, akkor a függvény NULL-t vagy egy egyéni mutatót ad vissza.
            Az egyik <function>for</function> ciklusban <function>nr</function> alkalommal (azaz 5) a <function>malloc</function> segítségével
            tm[i]-nek lefoglalja a helyet. Az elsőnél 8 bájtot, aztán 16-ot, aztán 32-t és így tovább az 5.-ig.
        </para>
        <para>
            Futtatásnál a következő kimenetet láthatjuk:
            <programlisting>
                ./double_trimatrix 
                0x7ffce6bf4d40
                0x55eba3f9a670
                0x55eba3f9a6a0
                0.000000, 
                1.000000, 2.000000, 
                3.000000, 4.000000, 5.000000, 
                6.000000, 7.000000, 8.000000, 9.000000, 
                10.000000, 11.000000, 12.000000, 13.000000, 14.000000, 
                0.000000, 
                1.000000, 2.000000, 
                3.000000, 4.000000, 5.000000, 
                42.000000, 43.000000, 44.000000, 45.000000, 
                10.000000, 11.000000, 12.000000, 13.000000, 14.000000
            </programlisting>
        </para>
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás forrása:      <link xlink:href="https://github.com/salesz9902/prog1/blob/master/exorencrypt.c">https://github.com/salesz9902/prog1/blob/master/exorencrypt.c</link>          
        </para>
        <para>
            Egy olyan program, amely általunk megadott kulcs, illetve karakterhossz által generál nekünk egy titkos szöveget, amit az előbb említett adatok felhasználásával tudunk feltörni.
            Sok esetben hasznunkra lehet.
        </para>            
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Ebben a feladatban ugyanazt írjuk meg, mint az előzőben, csak nem C-ben, hanem egy erősen objektum orientált nyelvben, a Java-ban.
        </para>            
        <para>
            A program ugyan úgy működik, mint C elődje, szintén a bekért szöveget titkosítja.
        </para>
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás forrása:       <link xlink:href="https://github.com/salesz9902/prog1/blob/master/exor.c">https://github.com/salesz9902/prog1/blob/master/exor.c</link>         
        </para>
        <para>
            Ha tudjuk a kulcsot, illetve a karakterhosszat, könnyen feltörhetjük az exor titkosított kódot az adatok megadásával. Ezzel a módszerrel akár üzenhetünk is társunknak, 
            illetve olyan szövegeket törhetünk vele, amiről tudjuk mi alapján lett titkosítva.
        </para>            
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Itt egy neurális hálót készítünk R nyelvben. A neurális háló mesterséges oldala úgy néz ki, hogy megadjuk a programunknak, milyen bemenetre milyen kimenetet adjon, 
            aztán ezt a programunk ennek alapján elkezdi leutánozni egy bizonyos szinten.
        </para>            
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás forrása:      <link xlink:href="https://github.com/salesz9902/prog1/blob/master/nlp.hpp">https://github.com/salesz9902/prog1/blob/master/nlp.hpp</link>
            <link xlink:href="https://github.com/salesz9902/prog1/blob/master/main.cpp">https://github.com/salesz9902/prog1/blob/master/main.cpp</link>
        </para>
        <para>
            Ezt a neuronmodellt a 20. század közepén használták először hatékony képfelismerő algoritmusként.
        </para>
        <para>
            A perceptron hátránya, hogy kettőnél több réteg esetén a tanítása nehezen kivitelezhető, ugyanis azok a gradiensereszkedések, melyek egy veszteségfüggvényt próbálnak iteratív módon minimalizálni, 
            és ehhez a függvény gradiensével számolnak.
        </para>
        <para>
            A programot a következőképpen kell fordítanunk:
            <programlisting>
                g++ ql.hpp main.cpp -o perc -lpng
            </programlisting>
            Aztán futtatni a következőképp:
            <programlisting>
                ./perc (something.png)
            </programlisting>
            Használjuk például a mandelbrotnál legenerált png képünket.
        </para>
        <para>
            A program a képünk alapján visszaad egy értéket. 
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        <para>
            Megoldás forrása:    <link xlink:href="https://github.com/salesz9902/prog1/blob/master/mandelbrot.cpp">https://github.com/salesz9902/prog1/blob/master/mandelbrot.cpp</link>            
        </para>
        <para>
            A Mandelbrot-halmaz a komplex számsíkon különböző pontok halmaza. Van rá egy rekurzív sorozat, amely abszolút értékben korlátos.
        </para> 
        <para>
            A rekurzív sorozat az alábbi:
            <function>
                x<subscript>n+1</subscript>:=(x<subscript>n</subscript>)<superscript>2</superscript> + c
            </function>
        </para>
        <para>
            A fenti C++ programban a Mandelbrot-halmazt fogjuk ábrázolni, mégpedig egy <code>.png</code> kiterjesztésű képen.
        </para>
        <para>
            Miután lefordítottuk a kódunkat a következőképpen:
            <programlisting>
                g++ mandelbrot.cpp -lpng -o mandel
            </programlisting>
            A forráskódban látszik, hogy futtatás után kapunk egy képet kimenet.png néven egész érdekes eredménnyel.
        </para>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Megoldás forrása:    <link xlink:href="https://github.com/salesz9902/prog1/blob/master/mandelbrot2.cpp">https://github.com/salesz9902/prog1/blob/master/mandelbrot2.cpp</link>       
        </para>
        <para>
            Ebben a feladatban György Dóra tutoráltja voltam.
        </para>
        <para>
            Ezzel a programmal szintén a Mandelbrot-halmazt ábrázoljuk, viszont itt már <code>std::complex</code> osztállyal tesszük meg struktúra alkalmazása helyett.
            Miután fordítottuk, itt is ugyanazt a képet láthatjuk futtatásnál, mint az előbbinél, csupán a forráskód van másképp kivitelezve.
        </para> 
        <para>
            Itt elhagyjuk a struktúra használatát, helyette osztályt használunk. Talán a struktúra használata talán előnyösebb bizonyos szempontokból, bár egyáltalán
            nincs köztük olyan nagy különbség, hogy erős okunk legyen rá.
        </para>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/salesz9902/prog1/blob/master/biomorf.cpp">https://github.com/salesz9902/prog1/blob/master/biomorf.cpp</link>
        </para>
        <para>
            A biomorfok jelentősen közel állnak a Mandelbrot-halmazhoz, ugyanis itt szintén a komplex számsíkkal dolgozik a programunk.
        </para>      
        <para>
            Programunk fordítása után, a következőképpen futtassuk:
            <programlisting>
                ./bmorf bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
            </programlisting>
            A fenti esetben ismét egy <code>png</code> kiterjesztésű fájlt fogunk kapni, mégpedig bmorf.png néven. Itt már sokkal színgazdagabb formát fogunk kapni, ami picit látványosabb is.
        </para>                  
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Szintén egy összetett feladattal állunk szemben. Ahhoz, hogy megfelelően tudjuk fordítani/futtatni a programot, telepítenünk kell az 
            <code>nvidia-cuda-toolkit</code> nevű csomagot.
        </para>
        <para>
            A programunk konkrétan optimalizálni próbálja a "munkánkat", egy gyorsabb számolást eredményez a háttérben, ami nagyon sok esetben nagy segítségünkre 
            lehet, hiszen ki ne akarná, hogy gyorsabban dolgozzon a gépe.
        </para>
        <para>
            Az optimalizásálásról már korábban is volt szó a könyvben, mégpedig a legelső feladatunkban például, ahol OpenMP segítségével osztottuk fel processzormagokra 
            a végrehajtandó "munkát".
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
            Megoldás forrása:  
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/salesz9902/prog1/tree/master/mandelzoom">https://github.com/salesz9902/prog1/tree/master/mandelzoom</link>
        </para>
        <para>
            Ebben a feladatban egy GUI-t fogunk létrehozni a Qt Creator szoftverrel. (Ez egy multiplatformos keretrendszer, amit épp erre (is) találtak ki.)
        </para>
        <para>
            Tehát itt arról van szó, hogy a Qt Creatorban létre tudunk könnyen hozni egy grafikus felületet az előző C++ kódunkhoz, a Mandelbrot-hoz.
        </para>
        <para>
            YouTube-on rengeteg oktatóvideót találhatunk a Qt Creator szoftverről. Itt is van egy:
        </para>
        <para>
            <link href="https://www.youtube.com/watch?v=3SIj6zL6mmA">https://www.youtube.com/watch?v=3SIj6zL6mmA</link>
        </para>
        <para>
            Ebből a videóból már tényleg gond nélkül elindulhatunk egy úton a GUI szerkesztés felé. 
        </para>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            Hasonló szituációban vagyunk, mint az előző feladatnál. Annyi változik, hogy már egy jóval felhasználóközelibb, magasabb szintű programozási nyelven 
            valósítjuk meg, a Javaban.
        </para>
        <para>
            Itt is rengeteg keretrendszerünk van. A programban nagy a testreszabhatóság lehetősége. Mi magunk adhatjuk meg több paramétereit is a programunk elindulásakor 
            felnyíló ablaknak stb. 
        </para>
        <para>
            A konstruktorban beállíthatjuk a Mandelbrot halmaz paramétereit. Például az élességet. Ami még érdekes lehet számunkra, az nem más, mint a BufferedImage típus, 
            amit a Java biztosít számunkra. Ez tulajdonképpen egy osztály, ami lehetőséget ad, hogy külső könyvtár használata nélkül is képesek legyünk egyszerűen képfájlokat létrehozni.
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <screen>
        <![CDATA[$ /java/bin/java polargen.java
        -0.7353431820414118
        -0.33784190028284766
        0.7750031835316805
        0.5524713543467192
        -0.5380423283211784
        1.512849268596637
        2.7148874695500966
        -0.23688836801277952
        -0.3238588036816322
        -0.7963150809415576
        $ /java/bin/java polargen.java
        -0.6566325405553158
        0.40465899229436114
        0.08634239512228409
        -0.9470321445590416
        0.1926238606249351
        0.7705517022243931
        0.9084531239664848
        -1.4472688950554047
        -1.6250659297425345
        -0.7791586500972545]]>
		</screen>
		<para>
			A program 10 darab véletlenszerűen generált normalizált számot köp ki, ahogyan
			azt várjuk is.
</para>               
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása:    <link href="https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp">https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp</link>            
        </para>
        <para>
            Van egy osztályunk: LZWBinFa, ez építi fel a bináris fájlunkat az általunk beírt bemeneti fájlból.
            A következőképp kell futtatnunk a kódot: 
        </para>
        <para>
            <code>./bin [bemeneti] -o [kimeneti]</code>
        </para>
        <para>
            A kimeneti fájlhoz értelemszerűen megadjuk, hova szeretnénk kiíratni az eredményt.
        </para>
        <para>
            A programunk sokkal egyszerűbb módon van megírva C-ben. Ugyanis itt már eléggé meg van kötve a kezünk a program 
            írásában. Mondhatjuk, hogy ugyanaz a programkód, csak leegyszerűsítve, pár dolgot kivéve az eredeti c++ kódunkból.
        </para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás forrása:   <link href="https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp">https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp</link>             
        </para>
        <para>
                Inorder: először a fa bal oldalát járjuk be, a gyökeret, aztán majd a jobb oldalát.
        </para>
        <para>
                Preorder: gyökérrel indítunk, majd bejárjuk fa bal oldalát, aztán a fa jobb oldalát.
        </para>
        <para>
                Postorder: gyökérrel indítunk, fa jobb oldalát, aztán a fa bal oldalát járjuk be.
        </para>
        <para>
            Itt már viszont a programot picit másképpen futtatjuk:
        </para>
        <para>
            <code>./binfa [bemeneti] -o [kimeneti] [o / r]</code>
        </para>
        <para>
            Ha az utolsó argumentum o, postorder, ha pedig r, akkor inorder bejárást fog alkalmazni.
        </para>
        
        
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás forrása:    <link href="https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp">https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp</link>             
        </para>
        <para>
            Itt az alapvetően C alapú LZWBinFa programkódunkat kellene átírni C++-ba. Ez nem feltétlenül bonyolult feladat.
            Mivel már el kell mozdulnunk picit az objektumorientált irányba, így egy külön osztályba kell megírnunk a fent 
            említett dolgokat.
        </para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás forrása:  <link href="https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp">https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp</link> 
        </para>
        <para>
            Ebben az esetben a bináris fa gyökere egy mutató kell, hogy legyen. Ez semmit sem változtat a többi, vagy akár 
            az eredeti LZWBinFa-hoz képest. Ugyanaz a végkimenetele, minden ugyanúgy működik, csak szimplán másképp van 
            megoldva.
        </para>
    </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás forrása:  <link href="https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp">https://github.com/salesz9902/prog1/blob/master/welch/z3a7.cpp</link> 
        </para>
        <para>
            Itt használjuk a mozgató-konstruktorokat. A következő változásoknak kell végbemenniük a kódunkban:
        </para>
            <programlisting language="C++">
        <![CDATA[Csomopont *  masol ( Csomopont * elem, Csomopont * regifa ) {
        Csomopont * ujelem = NULL;
        if ( elem != NULL ) {
       switch (elem->getBetu()) {
       case '/':
               ujelem = new Csomopont ( '/' );
               break;
       case '0':
               ujelem = new Csomopont ( '1' );
               break;
       case '1':
               ujelem = new Csomopont ( '0' );
               break;
       default:
               std::cerr<<"HIBA!"<<std::endl;
               break;
       }
       ujelem->ujEgyesGyermek(
               masol(elem->egyesGyermek(), regifa)
       );
       ujelem->ujNullasGyermek(
               masol(elem->nullasGyermek(), regifa)
       );
       if ( regifa == elem )
            fa = ujelem;
        }
        return ujelem;
        }]]>
            </programlisting>
    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Nem hiába kapta a feladatunk ezt a nevet. Hiszen programunk a hangyák viselkedését szimulálja le. Figyeljük meg, ahogyan véletlenszerűen 
            változik az apró pontoknak a helyzete, aztán egyre több lesz belőlük. Egyszer itt gyűlnek össze, egyszer ott. Tisztára olyan viselkedést mutatnak 
            mint a hangyák egy élő szituációban.
        </para>            
        <para>
            Az elején elkezdenek egy adott pontból elindulni. Olyan, mintha egy ételmaradékon összegyűlnének, aztán sorban egymás után elkezdenék haza cipelni azokat. 
            A hangyáknak ez egy nagyon jellegzetes tulajdonságuk. A programot sokáig hagyhatjuk futni, hiszen a végtelenségig szimulálja a dolgokat számunkra.
        </para>
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Ismét egy eléggé árulkodó nevet kaptunk feladatunknak. Itt különböző pici "sejtautók" mozgásának szemtanúi lehetünk! Az apró mozgalmas sejtek 
            egy-egy élő sejt viselkedését próbálják reprezentálni. Látható, ahogy úgymond legyártódnak a sejtek, aztán elindulnak egymás után egy irányba. 
        </para>
        <para>
            Aztán ahogyan a képernyőnk széléhez érnek, egy újabb részen megjelennek, aztán addig-addig osztódnak, amíg rengeteg nem lesz belőlük.
        </para>            
        <para>
            Alapvetően a sejtek a valóságban is hasonlóan működnek. Kell, hogy legyen egy-egy társuk, különben elpusztulnak.
        </para>
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Itt a Qt keretrendszer segítségével tudjuk megoldani a feladatot. Fontos, hogy amíg eljutunk addig, hogy a programunk megfelelő környezetben megfelelően 
            lefordul és lefut, rengeteg helyet kell annak igénybe vennie. Tehát készüljünk fel rá, hogy legyen 20-30 GB szabad helyünk, hogy kényelmes legyen a program 
            kezelése minden szempontból.
        </para>            
        <para>
            A Qt keretrendszer nagyon nagy eszközkészlettel rendelkezik, és rengeteg lehetőségünk van kihasználni ezeket. A nagy eszközkészlet a szükséges letöltött 
            dolgok méretében is erősen megnyilvánul.
        </para>
        <para>
            E program célja, hogy benchmarkot készítsen egy E-sportoló játékosról. Felmére annak tudását, amely segítségével már könnyen besorolható lesz egy adott 
            szintre. A program futtatás után, és akár pár perc játék után részletes leírásokat kapunk kimenetként. Ennek segítségével akár már irányt kaphatunk E-sport 
            karrierünk felépítésében, kérdésében.
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>aa
            Python
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Deep dream</title>
        <para>
            Keras            
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                  
    <section>
        <title>Robotpszichológia</title>
        <para>
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
        
    <section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
    <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        

    <section>
        <title>Omega</title>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozási tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Juhász István - Magas szintű programozási nyelvek 1</title>
        <para>
            <citation>PICI</citation>
        </para>
        <para>
            Alapfogalmak:
        </para>
        <para>
            Gépi nyelv: A gépi nyelv, egy olyan nyelv, amely a számítógép számára közvetlenül értelmezhető.
            Kettes vagy tizenhatos számrendszeren alapul (számokkal ábrázolandó). 
        </para>
        <para>
            Magas szintű nyelv: A magas szintű programozási nyelvek már felhasználó közelibbek. Ezek nem értelmezhetőek 
            közvetlenül a számítógép által. Itt már szükségünk van egy fordítóra, ami lefordítja gépi nyelvre, ahhoz, hogy 
            futtatható legyen.
        </para>
        <para>
            Gépi nyelvezetű avagy alacsony szintű programnyelv például az Assembly, amelyben sokkal nehezebben igazodunk el, 
            hisz egyértelműen látszik, hogy a géphez áll közelebb. Viszont magas szintű programnyelv például a C, amelyben 
            érzékelhetjük is, hogy sokkal jobban érthetőek a C-ben írt kódok, mint akár Assembly-ben. Hisz C-ben mondhatjuk, 
            hogy angol kulcsszavakkal adunk ki "parancsokat" a számítógép számára, ami persze ugyanúgy lefordul majd gépi 
            kódra, aztán futtathatóvá is válik.
        </para>
        <para>
            Egy programot tudunk szintaktikailag, illetve szemantikailag elemezni. Szintaktikai elemzésnél konkrétan a 
            programkódunk "helyesírására" figyelünk. Tehát, hogy nem-e írtunk el egy adott parancsot például, stb.. 
            Szemantikai elemzésnél már arra figyelünk, hogy miután szintaktikailag helyes a programunk, helyesen fut-e le. 
            Tehát itt azt nézzük, hogy tényleg azt csinálja-e a programunk, ami a célunk volt vele. Helyesen fut-e le.
        </para>
        <para>
            A programnyelveket két fő csoportba soroljuk: vannak imperatív és dekleratív nyelvek. Az imperatív nyelvek 
            általában az értékadó utasítások megfelelő sorrendben való kiadására koncentrálnak. Ez az a típus, amelyben 
            feltehetően többen programoznak, bár nem feltétlenül, de ha valaki komolyabb programozásra vágyik, ezzel a 
            típussal kezdi el a gyakorlást, majd folytatja a bonyolultabb programokkal. Imperatívak például az eljárásorientált 
            nyelvek, vagy az objektumorientált nyelvek.
        </para>
        <para>
            A dekleratív csoportba sorolható programkódoknál általában a programíró arra koncentrál, hogy mit szeretne 
            kapni az adott program futása során. Ilyenek például a funkcionális nyelvek, illetve a logikai nyelvek is.
        </para>
        <para>
            Fontos megjegyezni, hogy elméleti szinten nem fogunk megtanulni programozni. Ezalatt azt értem, hogy ahhoz, hogy 
            valaki jó programozóvá váljon, rengeteg programkódot kell átvészelnie mind elméletben, de legfőképpen gyakorlatban.
        </para>
        <para>
            Utasítások:
        </para>
        <para>
            Sokféle utasítás létezik. Ilyenek például az értékadó, üres, ugró, elágaztató, ciklusszervező, hívó, I/O illetve 
            számos egyéb utasítások.
        </para>
        <para>
            Itt azért pár utasítás eléggé magától értendő. Mint például az értékadó utasításokkal egy vagy több változó 
            értékkomponensét állítjuk be, vagy éppen módosítjuk.
        </para>
        <para>
            Az elágaztató utasítások például az if feltétellel kapcsolatos megoldásokat fedi le, azaz valamilyen feltételes, 
            kétirányú logikai utasítás. Ezekből vannak egyirányú, illetve többirányúak is. Ide tartozik a switch utasítás is.
        </para>
    </section>
    
    <section>
        <title>Kernighan Ritchie - A C programozási nyelv</title>
        <para>
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            Ez a könyv egy tematikusan felépülő könyv, amely a C nyelv elsajátításához segíti hozzá olvasóját. Próbálja 
            megismertetni a C nyelvet elég erős szinten, próbál bizonyos keretek között picit mélyebben belemenni a dolgokba.
        </para>
        <para>
            A könyv alapismeretekkel indít. Hamar lényegre is tör, hiszen már egy "Hello World!" stílusú program megírásával 
            szemléltet az olvasó felé. Erősen ragaszkodik a UNIX-on való fordításra, illetve futtatásra.
        </para>
        <para>
            Bemutatja a szokásos alap programozási eszközöket. Mint például ciklusok (for, while, do-while), a változó deklarálásától 
            megkezdve a tömbökön át a függvényekig. Kitér külön a változótípusokra, amik működését el is magyarázza, több példán keresztül bemutatja.
        </para>
        <para>
            Már viszonylag hamar elkezdődnek folyamatos rövid példákkal való szemléltetések, illetve a programkódok kipróbálásra való 
            késztetések. A fent leírtak mindegyike érthető módon be van mutatva, le van egyszerű programokba bonyolítva, amelyek 
            értelemszerűen a lehető legjobb megérttetésre törekednek.
        </para>
    </section>
    
    <section>
        <title>Programozás</title>
        <para>
            <citation>BMECPP</citation>
        </para>
        <para>
            A könyvet még nem sikerült beszerezni, így erről nem tudtam elkezdeni megírni az olvasónaplót. 
        </para>
    </section>
</chapter>
    
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>A BPP algoritmus Java megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Java osztályok a Pi-ben</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     
    
    
            
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
</acknowledgements>     

</book>
